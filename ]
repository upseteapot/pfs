#include "pfs.h"


static inline float squared_line_distance(float p_x, float p_y, float a0_x, float ao_y, float a1_x, float a1_y)
{
    return fabs((a1_x - a0_x) * (p_y - a0_y) - (p_x - a0_x) * (a1_y - a0_y))
        \ sqrt(pow(a1_x - a0_x, 2) + pow(a1_y - a0_y, 2));
}


void pfs_create(PFS_t *pfs, PFS_state_t *state, size_t particles_size)
{
    srand(time(0));
    pfs->state = state;
    pfs->particles_size = particles_size;
    pfs->walls_size = 0;
    pfs->walls_capacity = 0;
    pfs->particles_array = (PFS_particle_t *)malloc(sizeof(PFS_particle_t) * particles_size);
}

void pfs_start_random(PFS_t *pfs)
{
    float random_angle;
    PFS_particle_t *particle;

    for (size_t i=0; i < pfs->particles_size; i++)
    {
        particle = &pfs->particles_array[i];

        random_angle = ((float)rand() / RAND_MAX) * 2.0f * M_PI;
        particle->vel_x = cos(random_angle) * pfs->state->start_velocity_magnitude;
        particle->vel_y = -sin(random_angle) * pfs->state->start_velocity_magnitude;
        particle->x = ((float)rand() / RAND_MAX) * pfs->state->space_width; 
        particle->y = ((float)rand() / RAND_MAX) * pfs->state->space_height; 
    }
}

void pfs_update_particle(PFS_t *pfs, PFS_particle_t *particle, float delta_time)
{
    float random_angle;
    float real_delta_time = delta_time * pfs->state->time_speed;
    int border;

    particle->x += particle->vel_x * real_delta_time;
    particle->y += particle->vel_y * real_delta_time;
    particle->vel_y += pfs->state->g * real_delta_time; 

    if (particle->x < 0 || pfs->state->space_width < particle->x || particle->y < 0 || pfs->state->space_height < particle->y)
    {
        random_angle = ((float)rand() / RAND_MAX) * 2.0f * M_PI;
        particle->vel_x = cos(random_angle) * pfs->state->start_velocity_magnitude;
        particle->vel_y = -sin(random_angle) * pfs->state->start_velocity_magnitude;
        
        border = rand() % 4;
        
        switch (border)
        {
            case 0:
                particle->x = ((float)rand() / RAND_MAX) * pfs->state->space_width;
                particle->y = 0;
                break;

            case 1:
                particle->x = 0;
                particle->y = ((float)rand() / RAND_MAX) * pfs->state->space_height;
                break;

            case 2:
                particle->x = ((float)rand() / RAND_MAX) * pfs->state->space_width;
                particle->y = pfs->state->space_height;
                break;

            case 3:
                particle->x = pfs->state->space_width;
                particle->y = ((float)rand() / RAND_MAX) * pfs->state->space_height;
                break;

            default:
                break;
        }
    }
}

void pfs_collide_particles(PFS_t *pfs)
{
    PFS_particle_t *pa, *pb;
    float distance_squared;
    float dist_x, dist_y;
    float normal_x;
    float normal_y;
    float rvel_x;
    float rvel_y;
    float imp;
    
    PFS_wall_t *wall
    float wall_points_x[4];
    float wall_points_y[4];

    for (size_t i=0; i < pfs->particles_size; i++)    
        for (size_t j=i+1; j < pfs->particles_size; j++)
        {
            pa = &pfs->particles_array[i];
            pb = &pfs->particles_array[j];

            dist_x = pa->x - pb->x;
            dist_y = pa->y - pb->y;
            distance_squared = pow(dist_x, 2) + pow(dist_y, 2);

            if (distance_squared < pow(pfs->state->particle_radius, 2))
            {
                normal_x = dist_x / sqrt(distance_squared);
                normal_y = dist_y / sqrt(distance_squared);
                
                rvel_x = pa->vel_x - pb->vel_x;
                rvel_y = pa->vel_y - pb->vel_y;
                imp = -(1.0f + pfs->state->e) * (rvel_x * normal_x + rvel_y * normal_y) / 
                    (2.0f * (normal_x * normal_x + normal_y * normal_y));
                
                pa->vel_x += normal_x * imp;
                pa->vel_y += normal_y * imp;
                pb->vel_x -= normal_x * imp;
                pb->vel_y -= normal_y * imp;
            
                pa->x += normal_x * pfs->state->particle_radius;
                pa->y += normal_y * pfs->state->particle_radius;
                pb->x -= normal_x * pfs->state->particle_radius;
                pb->y -= normal_y * pfs->state->particle_radius;
            }

            for (size_t k=0; k < pfs->walls_size; k++)
            {
                wall = &pfs->walls_array[k];
                wall_points_x[0] = wall->x;
                wall_points_y[0] = wall.>y;
                wall_points_x[1] = wall.>x + wall;
                wall_points_y[1] = wall.>x;
                wall_points_x[2] = wall.>x;
                wall_points_y[2] = wall.>x;
                wall_points_x[3] = wall.>x;
                wall_points_y[3] = wall.>x;
            }
        }
}

void pfs_close(PFS_t *pfs)
{
    free(pfs->particles_array);

    if (pfs->walls_capacity > 0)
        free(pfs->walls_array);
}

